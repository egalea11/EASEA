/* -------------------- 0-1 Combinatorial Knapsack Problem -------------------------------

genome = population

FLOWCHART

-> populate random items
-> populate random individuals
-> calculate individuals fitness (loop until chromosome is modified to fit in knapsack)
REPEAT
    -> get elite individuals
    -> roulette wheel selection
    -> iterative single-point crossover
    -> random single-point mutation of individuals
    -> insertion of elite individuals
UNTIL - a termination condition (TIME, GENERATION, MIN FITNESS) is met
-> print best individual


The fitness function (evaluation) not only does it calculate fitness of individuals,
but makes the individuals eligible if the particular individual would result in
the knapsack being overweight.

Individuals are modified such as to accommodate the knapsack weight limit by
removing an item one by one from the individual, and checking for fitness each time.

This results in the fitness function having a time complexity of TODO calculate time complexity
however, only the first round is the most demanding since the evolution functions modify
(nearly) each individual only a bit.

----------------------------------------------------------------------------------------- */

\User declarations:
    #include <vector>

    // scenario settings
    #define MAX_ITEMS 5000               // maximum chromosome size
    #define MAX_KNAPSACK_WEIGHT 100      //
    #define CROSSOVER_PROB 0.8
    #define MUTATION_PROB 0.1

    // MIN/MAX bounds for item creation
    #define MIN_VALUE_PER_ITEM 8
    #define MAX_VALUE_PER_ITEM 20
    #define MIN_WEIGHT_PER_ITEM 1
    #define MAX_WEIGHT_PER_ITEM 5


\end

\User functions:

\end



\User classes:
    Item{
        int value;
        int weight;
    }
    GenomeClass{
        int x[MAX_ITEMS];
        Item *itemList[MAX_ITEMS];
    }


\end

\Before everything else function:
    std::cout << "Before everything else function called..." << std::endl;
\end

\After everything else function:
\end

\GenomeClass::initializer:
    std::cout << "initializer called..." << std::endl;
    // Populate list of items
    for (int i = 0; i < MAX_ITEMS; ++i) {
        Item *item = new Item;
        item->value = random(MIN_VALUE_PER_ITEM, MAX_VALUE_PER_ITEM);
        item->weight = random(MIN_WEIGHT_PER_ITEM, MAX_WEIGHT_PER_ITEM);
        Genome.itemList[i] = item;
    }
    // Populate genome
    for (int i = 0; i < MAX_ITEMS; i++) {
        Genome.x[i] = random(0,1);
    }
\end


\GenomeClass::crossover:
  for (int i=0; i<MAX_ITEMS; i++)
  {
    float alpha = (float)random(0.,1.);     // barycentric crossover
     child.x[i] = alpha*parent1.x[i] + (1.-alpha)*parent2.x[i];
  }
\end

\GenomeClass::mutator:      // return number of mutations
    int nbMutation = 0;
    for (int i = 0; i < MAX_ITEMS; i++){
        if (tossCoin(MUTATION_PROB)){
            Genome.x[i] = (Genome.x[i] + 1) % 2;
            nbMutation++;
        }
    }
    return nbMutation;
\end



\GenomeClass::evaluator:    // evaluate fitness
    int fitness;
    double totalValue, totalWeight;
    bool overweightFlag = false;
    std::vector<int> temp;
    int selectedElement;
    int count;

    do{ // while knapsack NOT overweight
        totalValue = totalWeight = fitness = 0;
        overweightFlag = false;
        for (int i = 0; i < MAX_ITEMS; ++i) {
            // if item selected in individual
            if(Genome.x[i] == 1){
                // add value and weight to total
                totalValue += Genome.itemList[i]->value;
                totalWeight += Genome.itemList[i]->weight;
                temp.push_back(i);
                if(totalWeight > MAX_KNAPSACK_WEIGHT){
                    overweightFlag = true;
                    break;
                }
            }
        }
        // if knapsack overweight, remove one item from chromosome at random
        if (overweightFlag){
            // randomize chromosome
            std::vector<int> availableIndexes;
            count = 0;
            selectedElement = 0;
            // find all elements in chromosome where item is '1'
            for (int j = 0; j < MAX_ITEMS; ++j) {
                if (Genome.x[j] == 1){
                    availableIndexes.push_back(j);
                    count++;
                }
            }
            // get a random element from availableIndexes vector
            selectedElement = availableIndexes.at(random(0, count));
            Genome.x[selectedElement] = 0;
            std::vector<int>().swap(availableIndexes);  // unallocated memory for temp vector
        }else{
            fitness = totalValue;

        // log best fitness as a struct
        /*
            if(bestChromLog.fitness < fitness){
                bestChromLog.chrom = x;
                bestChromLog.index = count;
                bestChromLog.fitness = fitness;
                bestChromLog.maxValue = totalValue;
                bestChromLog.maxWeight = totalWeight;
                bestChromLog.itemList = temp;
            }
        */
            Genome.fitness = fitness;
            temp.clear();
        }
    }while(overweightFlag);

    std::vector<int>().swap(temp); // clear allocated memory
    // std::cout << "fitness --> " << fitness;
    // std::cout << totalWeight << " <-- weight" << std::endl;
    return fitness;
\end



\GenomeClass::display:
\end




\Default run parameters:

  Number of generations : 300   	// NB_GEN
  Time limit: 0 			    // In seconds, 0 to deactivate
  Population size : 20			// number of chromosomes
  Offspring size : 10          // 40%
  Mutation probability : 0.1       // MUT_PROB
  Crossover probability : 0.8      // XOVER_PROB
  Evaluator goal : maximise      // Maximise
  Selection operator: Roulette
  Surviving parents: 1          //percentage or absolute
  Surviving offspring: 100%
  Reduce parents operator: Tournament 2
  Reduce offspring operator: Tournament 2
  Final reduce operator: Tournament 2

  Elitism: Strong			//Weak or Strong
  Elite: 2
  Print stats: true				//Default: 1
  Generate csv stats file: true
  Generate gnuplot script: true
  Generate R script: false
  Plot stats: true				//Default: 0

  Remote island model: false
  IP file: ip.txt 			// File containing all the remote island's IP
  Server port : 2929
  Migration probability: 0.3

  Save population: true
  Start from file: false

\end

